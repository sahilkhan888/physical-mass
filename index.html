<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cloth Physics</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #080808;
    height: 100vh;
    overflow: hidden;
    font-family: 'Space Grotesk', sans-serif;
    color: #ccc;
  }

  canvas { display: block; position: fixed; top: 0; left: 0; cursor: grab; }
  canvas:active { cursor: grabbing; }

  .upload {
    position: fixed; inset: 0; z-index: 10;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.4s, visibility 0.4s;
  }
  .upload.gone { opacity: 0; visibility: hidden; pointer-events: none; }

  .upload-card {
    width: 460px; padding: 72px 48px;
    border: 1px solid #1e1e1e; border-radius: 20px;
    background: #0d0d0d; text-align: center; cursor: pointer;
    box-shadow: 0 0 0 1px #1a1a1a, 0 0 80px rgba(255,107,53,0.06);
    transition: border-color 0.3s, transform 0.3s, box-shadow 0.3s;
  }
  @media (max-width: 440px) {
    .upload-card { width: calc(100vw - 48px); padding: 40px 24px; }
  }
  .upload-card:hover {
    border-color: #ff6b3540;
    box-shadow: 0 0 0 1px #ff6b3530, 0 0 100px rgba(255,107,53,0.12);
    transform: translateY(-3px);
  }
  .upload-card .icon { margin-bottom: 24px; }
  .upload-card h2 {
    font-family: 'Space Grotesk', sans-serif; font-size: 28px;
    font-weight: 700; color: #fff; letter-spacing: -0.5px;
  }

  @keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
  }
  .upload-card .icon svg { animation: float 2.8s ease-in-out infinite; }

  .tag {
    position: fixed; bottom: 28px; left: 50%;
    transform: translateX(-50%); z-index: 10;
    display: flex; flex-direction: column; align-items: center; gap: 16px;
    opacity: 0; transition: opacity 0.6s; white-space: nowrap;
  }
  .tag.show { opacity: 1; }
  .tag button {
    font-family: 'Space Grotesk', sans-serif; font-size: 12px;
    color: #fff; background: #ff6b35; border: none;
    padding: 10px 28px; border-radius: 8px; cursor: pointer;
    transition: background 0.2s, transform 0.15s;
  }
  .tag button:hover { background: #ff8555; transform: translateY(-1px); }
  .tag button:active { transform: translateY(0); }

  .hint {
    position: fixed; left: 50%;
    transform: translateX(-50%);
    z-index: 10; pointer-events: none;
    font-family: 'Space Grotesk', sans-serif; font-size: 22px; font-weight: 700;
    color: #fff; letter-spacing: -0.3px; text-align: center; white-space: nowrap;
    opacity: 0; transition: opacity 0.8s 0.3s;
  }
  .hint.show { opacity: 1; }
  @media (max-width: 600px) {
    .hint { font-size: 15px; white-space: normal; width: calc(100vw - 48px); }
  }

  .grid {
    position: fixed; inset: 0; pointer-events: none;
    background-image:
      linear-gradient(rgba(255,255,255,0.025) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.025) 1px, transparent 1px);
    background-size: 80px 80px;
  }

  #fi { display: none; }
  body.dragover .upload-card {
    border-color: #ff6b3580;
    box-shadow: 0 0 0 1px #ff6b3560, 0 0 160px rgba(255,107,53,0.22);
    transform: translateY(-3px);
  }
</style>
</head>
<body>
<div class="grid"></div>
<canvas id="c"></canvas>

<div class="upload" id="up">
  <label class="upload-card" id="uc" for="fi">
    <div class="icon">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#ff6b35" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
    </div>
    <h2>Upload an image</h2>
  </label>
</div>

<div class="hint" id="hint">Drag on the image to apply physical mass</div>

<div class="tag" id="tag">
  <button id="newBtn">+ new image</button>
</div>
<input type="file" id="fi" accept="image/*">

<script>
// ─── Device ──────────────────────────────────────────────────────────────────
const isMobile = ('ontouchstart' in window) || (window.innerWidth <= 768);

// ─── WebGL ───────────────────────────────────────────────────────────────────
const cvs = document.getElementById('c');
const gl  = cvs.getContext('webgl') || cvs.getContext('experimental-webgl');

// Vertex shader: converts cloth-point pixel coords → clip space
const VS = `
  attribute vec2 aPos;
  attribute vec2 aUV;
  uniform vec2  uRes;
  uniform vec2  uOff;
  varying vec2  vUV;
  void main() {
    vec2 p = (aPos + uOff) / uRes * 2.0 - 1.0;
    gl_Position = vec4(p.x, -p.y, 0.0, 1.0);
    vUV = aUV;
  }
`;

// Fragment shader: samples the image texture, applies alpha
const FS = `
  precision mediump float;
  varying vec2      vUV;
  uniform sampler2D uTex;
  uniform float     uAlpha;
  void main() {
    vec4 c = texture2D(uTex, vUV);
    gl_FragColor = vec4(c.rgb, c.a * uAlpha);
  }
`;

function mkShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog, mkShader(gl.VERTEX_SHADER,   VS));
gl.attachShader(prog, mkShader(gl.FRAGMENT_SHADER, FS));
gl.linkProgram(prog);
gl.useProgram(prog);

const loc = {
  aPos:   gl.getAttribLocation(prog,  'aPos'),
  aUV:    gl.getAttribLocation(prog,  'aUV'),
  uRes:   gl.getUniformLocation(prog, 'uRes'),
  uOff:   gl.getUniformLocation(prog, 'uOff'),
  uTex:   gl.getUniformLocation(prog, 'uTex'),
  uAlpha: gl.getUniformLocation(prog, 'uAlpha'),
};

const posBuf = gl.createBuffer();
const uvBuf  = gl.createBuffer();
const idxBuf = gl.createBuffer();
gl.enableVertexAttribArray(loc.aPos);
gl.enableVertexAttribArray(loc.aUV);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.clearColor(8/255, 8/255, 8/255, 1);

// ─── Dimensions ──────────────────────────────────────────────────────────────
let W, H;
let img = null, tex = null;
function resize() {
  // Cap DPR at 2 — no need for full 3x on tiny screen
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = innerWidth; H = innerHeight;
  cvs.width  = W * dpr;
  cvs.height = H * dpr;
  cvs.style.width  = W + 'px';
  cvs.style.height = H + 'px';
  gl.viewport(0, 0, cvs.width, cvs.height);
  if (img) buildCloth();
}
resize();
addEventListener('resize', resize);

// ─── Cloth config (fewer points on mobile) ───────────────────────────────────
const COLS       = isMobile ? 18 : 30;
const ROWS       = isMobile ? 18 : 30;
const ITERATIONS = isMobile ?  3 :  4;
const DAMPING    = 0.96;
const GRAVITY    = 0.25;
const RADIUS     = 45;

let pts = [], links = [];
let posData = null, indexCount = 0;
let mx = 0, my = 0, pmx = 0, pmy = 0, mdown = false;

// ─── Build cloth ─────────────────────────────────────────────────────────────
function buildCloth() {
  pts = []; links = [];

  const scale = Math.min((W * 0.55) / img.width, (H * 0.6) / img.height);
  const cw = img.width  * scale,  ch = img.height * scale;
  const ox = (W - cw) / 2,        oy = (H - ch) / 2;
  const sx = cw / (COLS - 1),     sy = ch / (ROWS - 1);

  const hintEl = document.getElementById('hint');
  hintEl.style.top = Math.max(16, oy - 68) + 'px';

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const x = ox + c * sx, y = oy + r * sy;
      pts.push({ x, y, ox: x, oy: y, px: x, py: y,
                 u: c / (COLS-1), v: r / (ROWS-1), pin: false });
    }
  }
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const i = r * COLS + c;
      if (c < COLS-1) links.push({ a: i, b: i+1,     rest: pdist(pts[i], pts[i+1])     });
      if (r < ROWS-1) links.push({ a: i, b: i+COLS,  rest: pdist(pts[i], pts[i+COLS])  });
    }
  }

  // UV buffer – static, set once
  const uvArr = new Float32Array(pts.length * 2);
  for (let i = 0; i < pts.length; i++) {
    uvArr[i*2] = pts[i].u;  uvArr[i*2+1] = pts[i].v;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
  gl.bufferData(gl.ARRAY_BUFFER, uvArr, gl.STATIC_DRAW);

  // Index buffer – static
  const idxArr = new Uint16Array((COLS-1) * (ROWS-1) * 6);
  let k = 0;
  for (let r = 0; r < ROWS-1; r++) {
    for (let c = 0; c < COLS-1; c++) {
      const i = r*COLS + c;
      idxArr[k++]=i;   idxArr[k++]=i+1;       idxArr[k++]=i+COLS;
      idxArr[k++]=i+1; idxArr[k++]=i+COLS+1;  idxArr[k++]=i+COLS;
    }
  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxArr, gl.STATIC_DRAW);
  indexCount = idxArr.length;

  // Position buffer – dynamic, pre-allocate storage once
  posData = new Float32Array(pts.length * 2);
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
}

function pdist(a, b) {
  const dx = b.x-a.x, dy = b.y-a.y;
  return Math.sqrt(dx*dx + dy*dy);
}

// ─── Physics ─────────────────────────────────────────────────────────────────
function step() {
  for (const p of pts) {
    if (p.pin) continue;
    const vx = (p.x - p.px) * DAMPING;
    const vy = (p.y - p.py) * DAMPING;
    p.px = p.x; p.py = p.y;
    p.x += vx; p.y += vy + GRAVITY;
  }

  if (mdown) {
    const dmx = mx - pmx, dmy = my - pmy;
    for (const p of pts) {
      const dx = p.x - mx, dy = p.y - my;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < RADIUS) {
        const s = ((RADIUS-d)/RADIUS) ** 2 * 1.6;
        p.px -= dmx * s; p.py -= dmy * s;
      }
    }
  }

  for (let it = 0; it < ITERATIONS; it++) {
    for (const l of links) {
      const a = pts[l.a], b = pts[l.b];
      const dx = b.x-a.x, dy = b.y-a.y;
      const d  = Math.sqrt(dx*dx + dy*dy) || 0.001;
      const diff = (l.rest - d) / d * 0.5;
      const cx = dx*diff, cy = dy*diff;
      if (!a.pin) { a.x -= cx; a.y -= cy; }
      if (!b.pin) { b.x += cx; b.y += cy; }
    }
    for (const p of pts) {
      if (p.pin) continue;
      p.x += (p.ox - p.x) * 0.003;
      p.y += (p.oy - p.y) * 0.003;
    }
  }
}

// ─── Render (WebGL — single draw call per frame) ─────────────────────────────
let lastTs = 0;
function render(ts = 0) {
  requestAnimationFrame(render);
  if (!img || !tex || !indexCount) return;
  // ~30 fps cap on mobile saves CPU/GPU budget
  if (isMobile && ts - lastTs < 32) return;
  lastTs = ts;

  step();

  // Stream updated positions to GPU with bufferSubData (avoids reallocation)
  for (let i = 0; i < pts.length; i++) {
    posData[i*2]   = pts[i].x;
    posData[i*2+1] = pts[i].y;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, posData);
  gl.vertexAttribPointer(loc.aPos, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
  gl.vertexAttribPointer(loc.aUV, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);

  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(loc.uRes, W, H);
  gl.uniform1i(loc.uTex, 0);

  // Shadow pass — desktop only (halves draw cost on mobile)
  if (!isMobile) {
    gl.uniform2f(loc.uOff, 6, 10);
    gl.uniform1f(loc.uAlpha, 0.04);
    gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
  }

  // Main pass
  gl.uniform2f(loc.uOff, 0, 0);
  gl.uniform1f(loc.uAlpha, 1.0);
  gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
}
render();

// ─── Input ───────────────────────────────────────────────────────────────────
cvs.addEventListener('mousedown',  e => { mdown = true;  mx = pmx = e.clientX; my = pmy = e.clientY; });
cvs.addEventListener('mousemove',  e => { pmx = mx; pmy = my; mx = e.clientX; my = e.clientY; });
cvs.addEventListener('mouseup',    () => mdown = false);
cvs.addEventListener('mouseleave', () => mdown = false);

cvs.addEventListener('touchstart', e => {
  e.preventDefault(); mdown = true;
  mx = pmx = e.touches[0].clientX; my = pmy = e.touches[0].clientY;
}, { passive: false });
cvs.addEventListener('touchmove', e => {
  e.preventDefault();
  pmx = mx; pmy = my;
  mx = e.touches[0].clientX; my = e.touches[0].clientY;
}, { passive: false });
cvs.addEventListener('touchend', () => mdown = false);

// ─── Texture ─────────────────────────────────────────────────────────────────
function createTexture(image) {
  if (tex) gl.deleteTexture(tex);
  tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
}

// ─── Load image ──────────────────────────────────────────────────────────────
function load(src) {
  const i = new Image();
  i.onload = () => {
    img = i;
    createTexture(i);
    buildCloth();
    document.getElementById('up').classList.add('gone');
    document.getElementById('tag').classList.add('show');
    document.getElementById('hint').classList.add('show');
  };
  i.src = src;
}

// ─── File input / drag & drop ────────────────────────────────────────────────
const fi = document.getElementById('fi');

function loadFromFile(file) {
  const r = new FileReader();
  r.onload = ev => load(ev.target.result);
  r.readAsDataURL(file);
}

fi.addEventListener('change', e => {
  if (!e.target.files[0]) return;
  loadFromFile(e.target.files[0]);
  fi.value = '';
});

document.getElementById('newBtn').addEventListener('click', () => fi.click());

document.addEventListener('dragover',  e => { e.preventDefault(); document.body.classList.add('dragover'); });
document.addEventListener('dragleave', ()  => document.body.classList.remove('dragover'));
document.addEventListener('drop', e => {
  e.preventDefault();
  document.body.classList.remove('dragover');
  const f = e.dataTransfer.files[0];
  if (f && f.type.startsWith('image/')) loadFromFile(f);
});

</script>
</body>
</html>
