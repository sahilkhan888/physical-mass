<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cloth Physics</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #080808;
    height: 100vh;
    overflow: hidden;
    font-family: 'Space Grotesk', sans-serif;
    color: #ccc;
  }

  canvas { display: block; position: fixed; top: 0; left: 0; cursor: grab; }
  canvas:active { cursor: grabbing; }

  .upload {
    position: fixed; inset: 0; z-index: 10;
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.4s, visibility 0.4s;
  }
  .upload.gone { opacity: 0; visibility: hidden; pointer-events: none; }

  .upload-card {
    width: 460px; padding: 72px 48px;
    border: 1px solid #1e1e1e; border-radius: 20px;
    background: #0d0d0d; text-align: center; cursor: pointer;
    box-shadow: 0 0 0 1px #1a1a1a, 0 0 80px rgba(255,107,53,0.06);
    transition: border-color 0.3s, transform 0.3s, box-shadow 0.3s;
  }
  @media (max-width: 440px) {
    .upload-card { width: calc(100vw - 48px); padding: 40px 24px; }
  }
  .upload-card:hover {
    border-color: #ff6b3540;
    box-shadow: 0 0 0 1px #ff6b3530, 0 0 100px rgba(255,107,53,0.12);
    transform: translateY(-3px);
  }
  .upload-card .icon { margin-bottom: 24px; }
  .upload-card h2 {
    font-family: 'Space Grotesk', sans-serif; font-size: 28px;
    font-weight: 700; color: #fff; letter-spacing: -0.5px;
  }

  @keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-5px); }
  }
  .upload-card .icon svg { animation: float 2.8s ease-in-out infinite; }

  .tag {
    position: fixed; bottom: 28px; left: 50%;
    transform: translateX(-50%); z-index: 10;
    display: flex; flex-direction: column; align-items: center; gap: 16px;
    opacity: 0; transition: opacity 0.6s; white-space: nowrap;
  }
  .tag.show { opacity: 1; }
  .tag button {
    font-family: 'Space Grotesk', sans-serif; font-size: 12px;
    color: #fff; background: #ff6b35; border: none;
    padding: 10px 28px; border-radius: 8px; cursor: pointer;
    display: flex; align-items: center; gap: 8px;
    transition: background 0.2s, transform 0.15s;
  }
  .tag button:hover { background: #ff8555; transform: translateY(-1px); }
  .tag button:active { transform: translateY(0); }

  .hint {
    position: fixed; left: 50%;
    transform: translateX(-50%);
    z-index: 10; pointer-events: none;
    font-family: 'Space Grotesk', sans-serif; font-size: 22px; font-weight: 700;
    color: #fff; letter-spacing: -0.3px; text-align: center; white-space: nowrap;
    opacity: 0; transition: opacity 0.8s 0.3s;
  }
  .hint.show { opacity: 1; }
  @media (max-width: 600px) {
    .hint { font-size: 15px; white-space: normal; width: calc(100vw - 48px); }
  }

  .grid {
    position: fixed; inset: 0; pointer-events: none;
    background-image:
      linear-gradient(rgba(255,255,255,0.025) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.025) 1px, transparent 1px);
    background-size: 80px 80px;
  }

  #fi { display: none; }
  body.dragover .upload-card {
    border-color: #ff6b3580;
    box-shadow: 0 0 0 1px #ff6b3560, 0 0 160px rgba(255,107,53,0.22);
    transform: translateY(-3px);
  }
</style>
</head>
<body>
<div class="grid"></div>
<canvas id="c"></canvas>

<div class="upload" id="up">
  <label class="upload-card" id="uc" for="fi">
    <div class="icon">
      <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#ff6b35" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
        <polyline points="17 8 12 3 7 8"/>
        <line x1="12" y1="3" x2="12" y2="15"/>
      </svg>
    </div>
    <h2>Upload an image</h2>
  </label>
</div>

<div class="hint" id="hint">Drag on the image to apply physical mass</div>

<div class="tag" id="tag">
  <button id="newBtn">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor"><path d="M440-440H240q-17 0-28.5-11.5T200-480q0-17 11.5-28.5T240-520h200v-200q0-17 11.5-28.5T480-760q17 0 28.5 11.5T520-720v200h200q17 0 28.5 11.5T760-480q0 17-11.5 28.5T720-440H520v200q0 17-11.5 28.5T480-200q-17 0-28.5-11.5T440-240v-200Z"/></svg>
    New Image
  </button>
</div>
<input type="file" id="fi" accept="image/*">

<script>
// ─── Device ──────────────────────────────────────────────────────────────────
const isMobile = ('ontouchstart' in window) || (window.innerWidth <= 768);

// ─── WebGL ───────────────────────────────────────────────────────────────────
const cvs = document.getElementById('c');
const gl  = cvs.getContext('webgl') || cvs.getContext('experimental-webgl');

// Vertex shader: converts cloth-point pixel coords → clip space
const VS = `
  attribute vec2 aPos;
  attribute vec2 aUV;
  uniform vec2  uRes;
  uniform vec2  uOff;
  varying vec2  vUV;
  void main() {
    vec2 p = (aPos + uOff) / uRes * 2.0 - 1.0;
    gl_Position = vec4(p.x, -p.y, 0.0, 1.0);
    vUV = aUV;
  }
`;

// Fragment shader: samples the image texture, applies alpha
const FS = `
  precision mediump float;
  varying vec2      vUV;
  uniform sampler2D uTex;
  uniform float     uAlpha;
  void main() {
    vec4 c = texture2D(uTex, vUV);
    gl_FragColor = vec4(c.rgb, c.a * uAlpha);
  }
`;

function mkShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog, mkShader(gl.VERTEX_SHADER,   VS));
gl.attachShader(prog, mkShader(gl.FRAGMENT_SHADER, FS));
gl.linkProgram(prog);
gl.useProgram(prog);

const loc = {
  aPos:   gl.getAttribLocation(prog,  'aPos'),
  aUV:    gl.getAttribLocation(prog,  'aUV'),
  uRes:   gl.getUniformLocation(prog, 'uRes'),
  uOff:   gl.getUniformLocation(prog, 'uOff'),
  uTex:   gl.getUniformLocation(prog, 'uTex'),
  uAlpha: gl.getUniformLocation(prog, 'uAlpha'),
};

const posBuf = gl.createBuffer();
const uvBuf  = gl.createBuffer();
const idxBuf = gl.createBuffer();
gl.enableVertexAttribArray(loc.aPos);
gl.enableVertexAttribArray(loc.aUV);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.clearColor(8/255, 8/255, 8/255, 1);

// ─── Dimensions ──────────────────────────────────────────────────────────────
let W, H;
let img = null, tex = null;
function resize() {
  // Cap DPR at 2 — no need for full 3x on tiny screen
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  W = innerWidth; H = innerHeight;
  cvs.width  = W * dpr;
  cvs.height = H * dpr;
  cvs.style.width  = W + 'px';
  cvs.style.height = H + 'px';
  gl.viewport(0, 0, cvs.width, cvs.height);
  if (img) buildCloth();
}
resize();
addEventListener('resize', resize);

// ─── Cloth config ────────────────────────────────────────────────────────────
const COLS       = isMobile ? 10 : 30;
const ROWS       = isMobile ? 10 : 30;
const ITERATIONS = isMobile ?  2 :  4;
const DAMPING    = isMobile ? 0.96 : 0.95;
const GRAVITY    = isMobile ? 0    : 0.06;
const RADIUS     = isMobile ? 110  : 65;
const R2         = RADIUS * RADIUS;

// Flat typed arrays — cache-friendly, no GC pressure
let pX, pY, pOX, pOY, pPX, pPY;   // point positions (cur, origin, prev)
let lA, lB, lRest;                  // link endpoints + rest lengths
let nPts = 0, nLinks = 0;
let posData = null, indexCount = 0;
let mx = 0, my = 0, pmx = 0, pmy = 0, mdown = false;

// ─── Build cloth ─────────────────────────────────────────────────────────────
function buildCloth() {
  nPts  = COLS * ROWS;
  nLinks = (COLS-1)*ROWS + COLS*(ROWS-1);

  pX   = new Float32Array(nPts);  pY   = new Float32Array(nPts);
  pOX  = new Float32Array(nPts);  pOY  = new Float32Array(nPts);
  pPX  = new Float32Array(nPts);  pPY  = new Float32Array(nPts);
  lA   = new Int32Array(nLinks);  lB   = new Int32Array(nLinks);
  lRest = new Float32Array(nLinks);

  const scale = Math.min((W * 0.55) / img.width, (H * 0.6) / img.height);
  const cw = img.width  * scale,  ch = img.height * scale;
  const ox = (W - cw) / 2,        oy = (H - ch) / 2;
  const sx = cw / (COLS - 1),     sy = ch / (ROWS - 1);

  const hintEl = document.getElementById('hint');
  hintEl.style.top = Math.max(16, oy - 68) + 'px';

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const i = r * COLS + c;
      const x = ox + c * sx, y = oy + r * sy;
      pX[i] = pOX[i] = pPX[i] = x;
      pY[i] = pOY[i] = pPY[i] = y;
    }
  }

  let lk = 0;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const i = r * COLS + c;
      if (c < COLS-1) {
        const j = i + 1;
        lA[lk] = i; lB[lk] = j;
        const dx = pX[j]-pX[i], dy = pY[j]-pY[i];
        lRest[lk] = Math.sqrt(dx*dx + dy*dy);
        lk++;
      }
      if (r < ROWS-1) {
        const j = i + COLS;
        lA[lk] = i; lB[lk] = j;
        const dx = pX[j]-pX[i], dy = pY[j]-pY[i];
        lRest[lk] = Math.sqrt(dx*dx + dy*dy);
        lk++;
      }
    }
  }
  nLinks = lk;

  // UV buffer – static, set once
  const uvArr = new Float32Array(nPts * 2);
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const i = r * COLS + c;
      uvArr[i*2] = c / (COLS-1);  uvArr[i*2+1] = r / (ROWS-1);
    }
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
  gl.bufferData(gl.ARRAY_BUFFER, uvArr, gl.STATIC_DRAW);

  // Index buffer – static
  const idxArr = new Uint16Array((COLS-1) * (ROWS-1) * 6);
  let k = 0;
  for (let r = 0; r < ROWS-1; r++) {
    for (let c = 0; c < COLS-1; c++) {
      const i = r*COLS + c;
      idxArr[k++]=i;   idxArr[k++]=i+1;       idxArr[k++]=i+COLS;
      idxArr[k++]=i+1; idxArr[k++]=i+COLS+1;  idxArr[k++]=i+COLS;
    }
  }
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idxArr, gl.STATIC_DRAW);
  indexCount = idxArr.length;

  // Position buffer – dynamic
  posData = new Float32Array(nPts * 2);
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, posData, gl.DYNAMIC_DRAW);
}

// ─── Physics ─────────────────────────────────────────────────────────────────
function step() {
  // spring = 0 while dragging (free deform), gentle on release
  const spring = mdown ? 0 : (isMobile ? 0.009 : 0.014);
  // fewer constraint passes while dragging on mobile — spring=0 so structure
  // barely matters mid-gesture; save the budget for the next frame
  const iters  = (mdown && isMobile) ? 1 : ITERATIONS;

  // Verlet integrate
  for (let i = 0; i < nPts; i++) {
    const vx = (pX[i] - pPX[i]) * DAMPING;
    const vy = (pY[i] - pPY[i]) * DAMPING;
    pPX[i] = pX[i]; pPY[i] = pY[i];
    pX[i] += vx;
    pY[i] += vy + GRAVITY;
  }

  // Touch / mouse drag influence
  // Uses squared-distance falloff — no sqrt, saves ~100 calls/frame on mobile
  if (mdown) {
    const dmx = mx - pmx, dmy = my - pmy;
    for (let i = 0; i < nPts; i++) {
      const dx = pX[i] - mx, dy = pY[i] - my;
      const d2 = dx*dx + dy*dy;
      if (d2 < R2) {
        const t = 1 - d2 / R2;   // 0→1 as point approaches cursor (no sqrt)
        const s = t * t * (isMobile ? 1.1 : 2.2);
        pPX[i] -= dmx * s; pPY[i] -= dmy * s;
      }
    }
  }

  // Constraint iterations
  for (let it = 0; it < iters; it++) {
    for (let l = 0; l < nLinks; l++) {
      const a = lA[l], b = lB[l];
      const dx = pX[b]-pX[a], dy = pY[b]-pY[a];
      const d  = Math.sqrt(dx*dx + dy*dy) || 0.001;
      const diff = (lRest[l] - d) / d * 0.5;
      const cx = dx*diff, cy = dy*diff;
      pX[a] -= cx; pY[a] -= cy;
      pX[b] += cx; pY[b] += cy;
    }
    // Gentle spring back to origin
    if (spring > 0) {
      for (let i = 0; i < nPts; i++) {
        pX[i] += (pOX[i] - pX[i]) * spring;
        pY[i] += (pOY[i] - pY[i]) * spring;
      }
    }
  }
}

// Soft stop — bleed off velocity instead of hard zero
function stopDrag() {
  mdown = false;
  // mobile: kill more velocity so cloth settles fast without oscillating
  const keep = isMobile ? 0.28 : 0.35;
  for (let i = 0; i < nPts; i++) {
    const vx = (pX[i] - pPX[i]) * keep;
    const vy = (pY[i] - pPY[i]) * keep;
    pPX[i] = pX[i] - vx;
    pPY[i] = pY[i] - vy;
  }
}

// ─── Render (WebGL — single draw call per frame) ─────────────────────────────
let lastTs = 0;
function render(ts = 0) {
  requestAnimationFrame(render);
  if (!img || !tex || !indexCount) return;
  // ~30 fps cap on mobile saves CPU/GPU budget
  if (isMobile && ts - lastTs < 32) return;
  lastTs = ts;

  step();

  // Stream updated positions to GPU with bufferSubData (avoids reallocation)
  for (let i = 0; i < nPts; i++) {
    posData[i*2]   = pX[i];
    posData[i*2+1] = pY[i];
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferSubData(gl.ARRAY_BUFFER, 0, posData);
  gl.vertexAttribPointer(loc.aPos, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
  gl.vertexAttribPointer(loc.aUV, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);

  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform2f(loc.uRes, W, H);
  gl.uniform1i(loc.uTex, 0);

  // Shadow pass — desktop only (halves draw cost on mobile)
  if (!isMobile) {
    gl.uniform2f(loc.uOff, 6, 10);
    gl.uniform1f(loc.uAlpha, 0.04);
    gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
  }

  // Main pass
  gl.uniform2f(loc.uOff, 0, 0);
  gl.uniform1f(loc.uAlpha, 1.0);
  gl.drawElements(gl.TRIANGLES, indexCount, gl.UNSIGNED_SHORT, 0);
}
render();

// ─── Input ───────────────────────────────────────────────────────────────────
cvs.addEventListener('mousedown',  e => { mdown = true;  mx = pmx = e.clientX; my = pmy = e.clientY; });
cvs.addEventListener('mousemove',  e => { pmx = mx; pmy = my; mx = e.clientX; my = e.clientY; });
cvs.addEventListener('mouseup',    stopDrag);
cvs.addEventListener('mouseleave', stopDrag);

cvs.addEventListener('touchstart', e => {
  e.preventDefault(); mdown = true;
  mx = pmx = e.touches[0].clientX; my = pmy = e.touches[0].clientY;
}, { passive: false });
cvs.addEventListener('touchmove', e => {
  e.preventDefault();
  pmx = mx; pmy = my;
  mx = e.touches[0].clientX; my = e.touches[0].clientY;
}, { passive: false });
cvs.addEventListener('touchend', stopDrag);

// ─── Texture ─────────────────────────────────────────────────────────────────
function createTexture(image) {
  if (tex) gl.deleteTexture(tex);
  tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
}

// ─── Load image ──────────────────────────────────────────────────────────────
function load(src) {
  const i = new Image();
  i.onload = () => {
    img = i;
    createTexture(i);
    buildCloth();
    document.getElementById('up').classList.add('gone');
    document.getElementById('tag').classList.add('show');
    document.getElementById('hint').classList.add('show');
  };
  i.src = src;
}

// ─── File input / drag & drop ────────────────────────────────────────────────
const fi = document.getElementById('fi');

function loadFromFile(file) {
  const r = new FileReader();
  r.onload = ev => load(ev.target.result);
  r.readAsDataURL(file);
}

fi.addEventListener('change', e => {
  if (!e.target.files[0]) return;
  loadFromFile(e.target.files[0]);
  fi.value = '';
});

document.getElementById('newBtn').addEventListener('click', () => fi.click());

document.addEventListener('dragover',  e => { e.preventDefault(); document.body.classList.add('dragover'); });
document.addEventListener('dragleave', ()  => document.body.classList.remove('dragover'));
document.addEventListener('drop', e => {
  e.preventDefault();
  document.body.classList.remove('dragover');
  const f = e.dataTransfer.files[0];
  if (f && f.type.startsWith('image/')) loadFromFile(f);
});

</script>
</body>
</html>
